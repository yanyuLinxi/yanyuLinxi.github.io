---
title: "Leetcode2_链表"
date: 2021-10-09T15:12:27+08:00
tags : [
   "leetcode学习"
]
categories : [
   "学习"
]
series : []
aliases : []
draft: false
---

# 203 移除链表元素

头节点是什么呢。头节点就是一个空的节点但指向第一个节点。保证了在处理其他节点的时候保持操作一致。返回的时候返回头节点的下一个节点。

头指针是指向第一个节点

# 707 设计链表

基本功题目

1. 用好头指针
2. 不要重复造轮子
3. 可以在leetcode中自己定义类。


# 206 反转链表

写的越来越得心应手了。目前看来没什么问题。在纸上思考好后再写就行。

可以使用临时变量存储部分值。

# 24 交换两个节点

想清楚一点。尽量想快一点。

多用头节点。
即使没传进来头节点。可以凭空创造一个头节点。


# 19 删除链表的倒数第N个节点

使用虚拟头节点。想清楚就行。


# 160 intersection of two Linked Lists

想清楚已经有的条件是什么。就从已经有的条件中进行分析。

这道题将尾部进行对齐。然后判断是否相同。

当然你投机取巧使用赋值也是不会做时的办法了。

这道题的解法真的非常有意思

网上存在的解法差异就是抵消差异，然后开始遍历。
有一种解法非常有意思：
https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49785/Java-solution-without-knowing-the-difference-in-len!
我们可以使用两次迭代来做到这一点。在第一次迭代中，我们将一个链表的指针在到达尾节点后重置到另一个链表的头部。在第二次迭代中，我们将移动两个指针，直到它们指向同一个节点。我们在第一次迭代中的操作将帮助我们抵消差异。所以如果两个链表相交，那么第二次迭代的交点一定是交点。如果两个链表根本没有交集，那么第二次迭代的相遇指针一定是两个链表的尾节点，为空。
 //if a & b have different len, then we will stop the loop after second iteration
    while( a != b){
    	//for the end of first iteration, we just reset the pointer to the head of another linkedlist
        a = a == null? headB : a.next;
        b = b == null? headA : b.next;    
    }
真的非常棒。


# 142 linked list cycle

这题非常有意思。判断链表是否有环。就要考虑有环的情况下会发生什么。

如果有环，我们会在里面绕圈圈。所以我们可以设置两个指针。一个快指针。一个慢指针。

快指针走两步。慢指针走一步。这样如果有环，两个指针一定会相遇。链表中能用到的就是指针。应该善用指针。

现在就需要找到环入口。

这里就要用到数学知识。这里的数学知识虽然比较简单但是很巧妙。最终得到的结论也是：
从入口到循环节点的距离等于相遇节点的距离到循环节点的距离。所以可以设置两个指针，同时出发。相遇时就找到了循环节点了。

可以说非常巧妙。

能学到的东西就是，善用指针。善用已知条件构造合理的等式。

1. 如果有环，则龟兔赛跑一定会相遇。类似于分针和秒针。
2. 根据条件设立实验条件。